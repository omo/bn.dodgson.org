---
title: "最近読んだ本 : Essential COM"
date: 2006-04-22
---
<h3>近況</h3>
<p>ビール仲間を求めて大学時代の友達に電話をしたら, 
もうすぐ退職して自営業者になると聞き驚く. 
会う度にやめるやめると言っていたのを, 
私は典型的なサラリーマンの愚痴と聞き流していた. 本気だったとは. 
自営業は営業活動が大変と伝え聞くが, 
彼はもともと外交的な体質なのでうまくやる気がする. </p>
<p>自営業者の友達がふえると, 
しめしめ, クビになったら雇ってもらおう ... などと考えてしまう自分に気付く. 
なさけない. 
<a data:asin='0691119430' href='http://www.amazon.co.jp/Gurus-Hired-Guns-Warm-Bodies/dp/0691119430%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0691119430'>Gurus, Hired Guns and Warm Bodies</a> を読んで以来, 
私は自分が正社員社会からドロップアウトするうわついた恐怖を捨て切れずにいる. 
なぜかはわからない. </p>
<p>気がつくと夜は深く, ビールも飲み損ねた. </p>
<h3>最近読んだ本 : <a data:asin='4756130666' href='http://www.amazon.co.jp/Essential-Addison-Wesley-Programming-Series/dp/4756130666%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4756130666'>Essential COM</a></h3>
<p>最近 C++ を使うことがあった. 
コードを書いてみると C++ 能力の低さに我ながらがっくりくる. 
なんというか, 自動的に書けない. 
自動的というのは
いちいち細かいことを気にせず体が覚えたイディオムに従ってコードを書く
あの感じ. 
私は Java ならそこそこ自動的に書ける. 
C++ だとそうはいかない. 自由度が高すぎて悩むことが多い. 
もう少しルールを縛って書きたい. しかし従うべき良いルールが見当たらない. </p>
<p>世間の職業 C++ プログラマはおそらく自分/会社なりの
ルールや枠組みを作っているのだろう. 
たとえばスマートポインタをどのくらい積極的に使うか, 
何を POD にするか, 参照カウントは使うか, QI 相当の仕組みをどう用意するか, 
何を仮想関数に, 何をテンプレートにするか, 例外をどのタイミングで投げるか, 
何をメンバ関数に, 何を free floating 関数にするか, など...
特定のフレームワークに乗るならその流儀に従えばいい. 
ただ私の場合フレームワークはいらない. ルールとイディオムがあればいい. 
とはいえ Effective C++ に類する教科書のルールはプリミティブ過ぎる. 
もう少し高位のルールと, それを支援するツールキットが欲しい. </p>
<p>で, ヒントを求めて読みなおした. COM は素晴しいね. 
私が最初にこれを読んだのはだいぶ前のことだ. 
その時はほとんど何も理解していなかったことがわかった. 
(そして今回もアパートメントのあたりはよくわからなかった.) 
当時色々わかっていなかったことはあるが, 
あの頃は特にコンポーネントやコンテナについてわかってなかった気がする. 
だからコンテナが何をしてくれるかという視点を欠いていた. 
スレッドまわりの保護やマーシャリングなど, かなり色々やってくれるんだね. </p>
<p>たぶん COM プログラマはかなり自動的にコードを書けるのだと思う. 
COM のモデルに従った "良い" スタイルは限られている. 
こんな風に確立したルールやプロトコルでコードを束縛したい. 
ただ私は当面 Win32 で仕事をすることはないから COM は使えない.  
それに, COM はちょっと古い. 
(Microsoft のサイトにすら COM の仕様書は見当らない. obsolete すぎる...
誰か持ってたらください.) 
言語中立やコンパイラ中立などがいくらかオーバースペックでもある. 
もう少し軽量モダンかつ堅牢な C++ のプログラミングモデルが欲しい. </p>
<p>最近の C++ は私が期待している方向への進歩はしていない気がする. 
プログラミングモデルを縛るという目的では <a href="http://boost.org/">boost</a> も <a href="http://www.artima.com/cppsource/cpp0x.html">c++0x</a> も役に立たない. 
boost や STL は主義主張をしないよう
注意深く generic に書かれている. (だから使いやすい.) 
しかしアプリケーションのコードを generic に書くのはコストが高過ぎる. 
genricity を利用して specific なコードを書く
平民アプリケーション・プログラマへの関心を C++ 界隈は欠いている気がする. 
平民(私)は genericity にもメタプログラミングも大して興味はない. 
アプリケーションのドメインモデルを手早くコードに落として動かしたいだけ. 
その際に, スタイルが一貫し可読性が高く, 規模が大きくなっても破綻せず, 
バグが入らず, コンパイル時間が現実的で, 性能もそこそこ, 
そんな基盤の上で自動的にコードを書きたい. </p>
<p>だいぶ甘えたことを言っている気がしてまいりました...
修行が足りないだけかもしらん. 
<a data:asin='4756131662' href='http://www.amazon.co.jp/Effective-Addison-Wesley-Programming-Series/dp/4756131662%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4756131662'>Effective COM</a> も読みたい. しかしかなり難解だと伝え聞き躊躇中. </p>
<h3>最近読んだ本 : <a data:asin='0201834545' href='http://www.amazon.co.jp/Inside-Object-Model-Stanley-Lippman/dp/0201834545%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0201834545'>Inside C++ Object Model</a></h3>
<p><span class='image'><a href='http://www.amazon.co.jp/Inside-Object-Model-Stanley-Lippman/dp/0201834545%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0201834545' class='bookcover'><img data:asin='0201834545' class='asin image-right' src='http://ecx.images-amazon.com/images/I/51M0RWZW29L.jpg'></span></a></span></p>
<p>C++ 繋がりで勢いあまって読む. </p>
<p>cfront の開発者が C++ のコードはコンパイルされるとどうなるのかを解説する. 
コンパイル結果はだいたいこんな C のコードと等価になりますという話が中心. 
暗黙に生成/実行される関数群, 一時オブジェクト, クラスのバイナリレイアウト, 
コンストラクタの実行順序, vtbl ...
各種 C++ の教科書だとこうした話題は断片的に登場するだけだ. 
それを一望できるのはいい. </p>
<p>そして一望するとかなり気が滅入る. 
たとえば, 多重継承の話がかなり念入りに議論される. 
C++ の教科書を読む時は どうせ多重継承なんて使わないよね... と, 
心がフィルタアウウトしていた話題だ. 
それと向かい合うことになる. かなりややこしい. 
仮想継承なんて最悪だ. たとえば</p>
<pre>class A { .. };
class B : virtual public A { ... };
class C : virtual public A { ... };
class D : public B, public C { ... };</pre>
<p>とクラスを定義した時, B や C のコンストラクタは
自分の初期化だけをするバージョンと A のコンストラクタも呼び出すバージョンの
二種類が生成される. D のコンストラクタでは B, C のコンストラクタのうち
自分の初期化だけをするバージョンを使う. 
B を直接インスタンス化する場合は 
A のコンストラクタを呼ぶバージョンのコンストラクタが使われる. 
...というような話. gcc -S して確認すると
たしかに二種類のコンストラクタが生成されていた. うええ...
C++ は主記憶の消費ならなんとか予想できるけど, 
コードサイズはさっぱり見当がつかない. これだけ色々やられては仕方ない. </p>
<p>そのほかにも仮想クラスへアクセスする際の offset を vtbl に保存する話, 
多重継承をした仮想関数の呼び出しに使われる thunk のアイデアなど, 
C++ マニア垂涎, 良心的なプログラマは逃げだしたくなる話題ばかり. 
JavaScript 仕様を馬鹿にした自分を心から反省. </p>
<p>古い本なので例外や RTTI の扱いは軽い. 
RTTI はともかく, 例外は生成されるコード全般に影響があるはず. 
詳しく説明してほしかった. 
著者によると cfront は例外をサポートしきれず頓挫したという. 
要するに C のソースコード生成ではまともに扱えない機能というわけか. 
想像を越えて厄介そうだ. </p>
<p>薄くて字が大きいのは良いが, 英語はわかりにくい. たぶん文章が下手なんだと思う. 
また製本はひどい. 字の歪んでる部分が多い. (私が外れをひいただけかもしれない.) 
値段も高いのであまりお勧めできる本ではない. 
暇なので読みたいという方はメールもらえればお貸しします. </p>
<h3>最近読んだ本 : <a data:asin='4873110270' href='http://www.amazon.co.jp/JavaScript-%E3%83%87%E3%82%A4%E3%83%93%E3%83%83%E3%83%89-%E3%83%95%E3%83%A9%E3%83%8A%E3%82%AC%E3%83%B3/dp/4873110270%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873110270'>JavaScript 第三版</a></h3>
<p><span class='image'><a href='http://www.amazon.co.jp/JavaScript-%E3%83%87%E3%82%A4%E3%83%93%E3%83%83%E3%83%89-%E3%83%95%E3%83%A9%E3%83%8A%E3%82%AC%E3%83%B3/dp/4873110270%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873110270' class='bookcover'><img data:asin='4873110270' class='asin image-right' src='http://ecx.images-amazon.com/images/I/51DFB18AYPL.jpg'></span></a></span></p>
<p>Shibuya.js の帰りに購入. </p>
<p>良い本だった. かなり詳しく細かい話まで書いてある. 
これを読めば仕様書は読まなくても良さそう. 
仕様書は細かい API を調べるに便利だけれど, 通読するのは面倒だ. 
良い本があるならそれに越したことはない. 
また仕様書と違い利用者向けに書かれていてわかりやすい. 
私は Call オブジェクトのあたりをよくわかっていなかったが, 
これを読んでようやくわかった. </p>
<p>ECMAScript 仕様だけでなく Netscape 拡張も載っているのは面白い. 
Closure オブジェクトなんてものがあるとは知らなかった. 
まだあるんだろうか. (...なかった.)</p>
<p>前半は JavaScript の解説, 後半は DOM の解説になっている. 
DOM の部分は概要を知るにはよい. 
私は HTML DOM (!= XML DOM) をよく知らなかったので読みではあった. 
ただ実用性は低いかもしれない. 参照している実装が古い. 
今更 NN4 の問題がどうこう言われても興味がわかない. </p>
<p>その実用性の低さも歴史的な資料としては面白い. たとえば DOM の イベントモデル. 
IE は bubbring を, NN は capturing を実装していて互換性はないとある. 
私は DOM Event 仕様を見たとき, 
なぜ bubbring と capturing の二種類の伝播モデルがあるのか
さっぱりわからなかった. 実装の和だったのか. 謎がとけた. 
ほかにもあるバージョンではバグがあって他のバージョンでは直っている, 
という類の話は多い. 進歩の過程が見えて楽しい. </p>
<p>"Writing Solid JavaScript" には足りないけれど, 
"プログラミング言語 JavaScript" としての役割は果たせる本だと思う. 
勧める人が多いのも納得できた. </p>
<h3>最近読んだ本 : <a href="https://gettingreal.37signals.com/">Getting Real</a></h3>
<p>Backpack や RoR で知られる <a href="http://37signals.com/">37signals</a> が
自社の開発プロセスや技法について書いた本. なかなかミーハー心をくすぐる. </p>
<p>大企業を目指さない謙虚さと優秀なスタッフによって実現できる
超アジャイルなソフトウェア開発とはこういうものだ, という内容. なかなか刺激的. 
一方で, これを実現できる暗黙の前提は厳しい. 
特に開発や運営のプロセスについてはそれが顕著. 
大半の読者にとってはとても真似できそうにない. 
書評を見ても, "いい方法だと思うけどうちじゃムリだよねー" という反応が多い. 
exMSFT のプロジェクト・マネージャ Scott Berkun は
<a href="http://www.scottberkun.com/blog/?p=254">レビューの中</a>で, 
この非現実さは彼らの経験不足からくる限界だと指摘する. 
要するに恵まれない現場を知らないのだと. 説得力がある. 
きっと 37signals はタレント揃いなんだろうね. </p>
<p>とはいえ, そういう政治的な部分をさて置くと学ぶべき話題は多い.
"Interface Design" と "Wording" の章 (どちらも UI の話) は 
37signals 製アプリケーションの小粋さがうまくまとまっており, とても面白かった. 
(個人的には機能選定と UI を掘り下げて本を書いて欲しい. 
<a data:asin='4839916063' href='http://www.amazon.co.jp/%E3%83%87%E3%82%A3%E3%83%95%E3%82%A7%E3%83%B3%E3%82%B7%E3%83%96%E3%83%BB%E3%82%A6%E3%82%A7%E3%83%96%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%81%AE%E6%8A%80%E8%A1%93%E2%80%95%E3%80%8C%E3%81%86%E3%81%BE%E3%81%8F%E3%81%84%E3%81%8B%E3%81%AA%E3%81%84%E3%81%A8%E3%81%8D%E3%80%8D%E3%81%AB%E5%82%99%E3%81%88%E3%81%9F%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%80%81%E3%80%8C%E4%B8%8A%E6%89%8B%E3%81%AB%E3%80%8D%E9%96%93%E9%81%95%E3%81%88%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3-Web-designing-books-37signals/dp/4839916063%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4839916063'>ディフェンシブ・ウェブデザインの技術</a> も面白かったけれど, 逆に話題を絞りすぎ.) </p>
<p>プロセスの部分については, 
趣味プログラミングの方法論だと思って読むといいかもしれない. 
たとえば機能追加について "まず NO という" 姿勢を, 
無茶な野心で自滅しがちな趣味プログラマは見習っていいだろう. 
メジャーソフトと競合しようと思わずニッチをつけという話も同様. 
地味でも便利なソフトウェアを小さなコストで楽しく作ろうという
意思が通底している. 
それで金を稼げるかには議論があるのだろうけれど, 
基本理念そのものには同意できると思う. </p>
<p>とても薄いくて字も少い. 新書みたいなかんじ. PDF のみ. </p>
<h3>最近読んだ本 : <a data:asin='4166605011' href='http://www.amazon.co.jp/%E3%82%B0%E3%83%BC%E3%82%B0%E3%83%AB%E2%80%95Google-%E6%97%A2%E5%AD%98%E3%81%AE%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%82%92%E7%A0%B4%E5%A3%8A%E3%81%99%E3%82%8B-%E6%96%87%E6%98%A5%E6%96%B0%E6%9B%B8-501-%E4%BD%90%E3%80%85%E6%9C%A8/dp/4166605011%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4166605011'>グーグル—既存のビジネスを破壊する</a></h3>
<p><span class='image'><a href='http://www.amazon.co.jp/%E3%82%B0%E3%83%BC%E3%82%B0%E3%83%AB%E2%80%95Google-%E6%97%A2%E5%AD%98%E3%81%AE%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%82%92%E7%A0%B4%E5%A3%8A%E3%81%99%E3%82%8B-%E6%96%87%E6%98%A5%E6%96%B0%E6%9B%B8-501-%E4%BD%90%E3%80%85%E6%9C%A8/dp/4166605011%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4166605011' class='bookcover'><img data:asin='4166605011' class='asin image-right' src='http://ecx.images-amazon.com/images/I/41OP4pHY9BL.jpg'></span></a></span></p>
<p>ファンブックとして購入. </p>
<p>なかなか面白い. NHK スペシャルを見ている気分. よく取材している. </p>
<p>ただ世間の "アルゴリズム = 中立公正" という感覚はなんとか訂正したい. 
"コンピュータ = 間違えない" の亜種なのだろうけれど, 
この誤解は早めに解いておかないと色々不都合がありそう. 
( 誰か:"グーグルはこっちが正しいっていってるよ!" 
私:"うるせー, それは仕様がバグってるんだ!" とか. ) 
今までも似たような議論はあったのけれど, 
これまではやれやれと肩をすくめていればよかった. 
しかしこのイメージを恣意的に利用するアルゴリズム原理主義者が現れると話は別. 
部外者(私)がとばっちりを受けかねない. </p>
<p>一方で, けっこう根深い問題のような気もする. 
数式を目にした時の思考停止と同根なら厄介だ. 
少し考える必要がありそう. </p>
