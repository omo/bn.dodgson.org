---
title: "ボトルネックとホットスポット"
date: 2007-07-15
---
<h3>ボトルネックとホットスポット</h3>
<p><span class='image'><a href='http://www.amazon.co.jp/%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%BF%E3%82%A4%E3%83%A0-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-Tomas-Akenine-Moller/dp/4939007359%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4939007359' class='bookcover'><img data:asin='4939007359' class='asin image-right' src='http://ecx.images-amazon.com/images/I/51h5tADC7zL.jpg'></span></a></span></p>
<p>昨日の <a data:asin='4939007359' href='http://www.amazon.co.jp/%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%BF%E3%82%A4%E3%83%A0-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0-%E7%AC%AC2%E7%89%88-Tomas-Akenine-Moller/dp/4939007359%3FSubscriptionId%3D0SRV0GVS2Q5FGJTWHV82%26tag%3Dstepstophanta-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4939007359'>RTR</a> 読書会はパイプライン最適化の話だった. 
改めて読むと面白い. 各種高速化チップスはさておき, 
パイプラインの遅い部分, ボトルネックを特定する方法が興味深かった. 
(ゲーム屋さんには当たり前の話だと思います.) </p>
<p>グラフィクス・アプリケーションのパイプラインはおおよそ以下のようなものだ: 
CPU でデータを作り, それを GPU に送る. 
GPU ではまず geometry ステージ (vertex shader とか) が頂点情報を計算し, 
それを rasterize ステージ (pixel shader とか) がピクセルに変換, 
frame buffer に書き込む. 
データは図の左から右に流れる. この流れっぷりがパイプラインと呼ばれる所以. </p>
<p><img src="http://dodgson.org/omo/t/images/20070715_0.png" class="diagram" /></p>
<p>パイプラインの各ステージは基本的に並列して動く. 
だから全体の実行時間は最も遅いステージの所要時間になる. 
各ステージの合計ではない. 
だから速いステージを更に速くしたところで意味がない. まさにボトルネック. 
ボトルネックという呼び名は素朴な世界の高速化でも使う.  
コンポーネントの合計処理時間が実行時間になるようなケースね. 
そういうのはホットスポットと呼んでおこう. 語弊が少い. </p>
<p>ホットスポットの世界では, ホットスポット以外を速くしても多少は意味がある. 
50% の処理時間を占める部分が速くできないとき, 
30% を占める部分が倍速くなれば 15% 高速になる. 
ボトルネックの世界では合計に意味がない. 
逆に暇なステージは足並みが揃うまで負荷を増やすことができる. 
geometry ステージがボトルネックなら pixel shader を派手にしてもいい. </p>
<p><img src="http://dodgson.org/omo/t/images/20070715_1.png" class="diagram" /></p>
<p>ボトルネックの世界では,
CPU プロファイラの上位リストを潰していく伝統的な高速化だけだと歯が立たない. 以前 
"CPU レベルで頑張る人が多いんだけど, 全然意味ないんだよねえ..." 
とゲーム屋さんがぼやくのを聞いた. 
でも頑張る人の気持ちもわかる. 世界は素朴だと信じたいんだよね. 勝手に共感. </p>
<p>RTR ではボトルネックを特定する方法が紹介されている. 
CPU ステージを調べるのは比較的簡単だ. 
グラフィクス API の呼び出しをダミーに差し替えればいい. 
ダミーを使っても速度が変わらなかったら CPU がボトルネックだとわかる. 
ただし, ステージそのものではなくステージ間の通信(CPU と GPU の通信)が
ボトルネックになることもある. その判断には素朴な API 差し替え以上の工夫が必要になる. </p>
<p><img src="http://dodgson.org/omo/t/images/20070715_2.png" class="diagram" /></p>
<p>GPU の各ステージを調べるのはもう少し難しい. 
GPU を測りたいからといって CPU ステージを無効にはできない. 入力がなくなってしまう. 
geometry ステージは特に難しい. 先の問題に加え, 
単純に geometry 処理を無効化すると rasterize ステージの計算量まで変わってしまう. 
出口にも入口にも気を使わなければいけない. 
だから出力を変化させず負荷を調査したい. RTR では照明の数を調節する方法が紹介されている. 
照光計算を無効にして速くなれば, geometry ステージがボトルネックだとわかる. 
少し一般的に言うなら, 頂点演算のうち頂点色の計算負荷を調整すればいいと言える. 
頂点位置やテクスチャ座標を変えると rasterize の負荷に影響してしまう. </p>
<p>その rasterize ステージは簡単. 
今ならシェーダを空(kill)にすればいい. frame buffer を小さくしてもいい. </p>
<p>...なんてのを感心しながら読んでいたら, ボトルネック解消に関する NVIDIA のスライドを教えてもらった: "<a href="http://developer.nvidia.com/object/practical_perf_analysis.html">Practical Performance Analysis and Tuning (2004)</a>" RTR の議論より細かい話で, たとえばステージも 7 つに分割している. そのほか生々しすぎて門外漢には辛い話も多いけれど, 細かな落とし穴のフォローは実務で役立つのだろう. </p>
<h4>ボトルネックとテスト可能性</h4>
<p>先のスライドではボトルネック特定の技法を二種類に分類している. </p>
<ul>
<li>あるステージを書き換えてみる</li>
<li>あるステージ以外を無効化してみる</li>
</ul>
<p>あとは複数のテストをしろと補足している. 
他に影響を与えずステージを変更するのは難しい. 
勘違いを避けるために追試するわけね. </p>
<p>ボトルネックを特定するこの方法論はグラフィクス以外でも役に立つ気がする. 
少しでも非同期な性質を持つプログラム, 
出口と入口で時間を測るだけだと不十分なコードには
こうしたアプローチが効くだろう. 友人とそんな話をした. </p>
<p>たとえばノンブロック I/O を使ったネットワークプログラムはこれにあたる. 
カーネルとアプリケーションは並列に動く. 
ユーザランドの処理を速くしたところで帯域がボトルネックかもしれない. 
逆に自分のコードが遅いこともあるだろう. それを確かめたいなら
各ステージを差し替えられるようにしておく必要がある. 
システムコールをダミーに差し替えても良いだろう. (けど, もうちょっと上で切りたい...)</p>
<p>XHR を使ったウェブアプリケーションも非同期だ. 
データの送受信とクライアントコードは並列に動く. 
受け取った XML を処理するコードが遅いかもしれないし, サーバや経路が遅いかもしれない. 
XHR の受信部分をダミーに差し替えればそれを調べることができるだろう. 
非同期とは違うけれど, スクリプトの実行後に動くレイアウト処理も出口調査ができない点で
非同期と似ている. その負荷の程度もレイアウトを無効化すれば特定できる. 
(スタイルで工夫するといいらしい. 友人談.)</p>
<p>ボトルネックの特定しやすさと
テスト可能性には関係がありそうだ. 
あるモジュールがテスト可能であるためには 
その依存先をテスト用スタブに差し替えられなければいけない. 
これは "あるステージ以外を無効化する" という条件の一般化だと言える. </p>
<p>ただしこの条件は十分でない. 
ボトルネックを調べたいならモジュール単体でなく
(一部を無効化した)アプリケーション全体を動かしたいと思うだろう. 
アプリケーションにはそうした設定を許す柔軟さが求められる. 
ダミーのモジュールを作るのも面倒が多い. 
正しい値を返すだけでなく, 実運用に近い負荷を作りたい. 
単体テストのモックを書くよりは大変そう. </p>
<p>こう考えると非同期アプリケーションの高速化はとても難しいものに思えてくる. 
アドホックなチューニングでは歯が立ちそうにない. 
おそらく設計段階から計測の枠組みを仕込んでおかないとつらい. 
単体テストはそう仕向ける圧力になるが, もう一歩踏み込む必要がある. 
こりゃ大変だわ. 
世間の非同期なウェブアプリケーションが緩慢なのも仕方ない. やや同情した. 
ゲーム屋さんはエライ. </p>
<p>私も他人事みたいな顔をしてられない気がするけどね...</p>
<p>思いだしたようにまとめ:</p>
<ul>
<li>グラフィクスのパイプライン最適化は非同期アプリの高速化に応用できそう<ul>
<li>あるステージを書き換えてみる</li>
<li>あるステージ以外を無効化してみる</li>
</ul></li>
<li>でも大変<ul>
<li>モジュールの依存先を差し替え可能にする必要あり</li>
<li>差し替えた状態のアプリで測定できる必要あり</li>
</ul></li>
</ul>
