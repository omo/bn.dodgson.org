---
title: "Building Application Frameworks は挫折"
date: 2004-04-29
---
<p>近況</p><p>"Building Application Frameworks" は挫折. 多数の著者によって各節が独立して書かれており, 記述に重複が多い. だから厚さほどの情報量はない. 内容を選り分ける気力が尽きた. トピックが独立だから, 中断して内容を忘れかけてもあまり害はあるまい. また気がむいたら読もう.</p><p></p><p>ある派閥争いの話</p><p>まわりの同僚達にはフレームワーク派とライブラリ派がいる. 以前, 同僚 B とそんな話をした. 利用者にインターフェイス(Java の interface/C の コールバック関数)の定義を要求するのがフレームワーク派, 自分のモジュールを呼出させるのがライブラリ派. 適切な設計は状況によって異り, 単純にこのどちらが優れているということはない. だからフレームワーク派/ライブラリ派という区分は意思決定での閾値が持つ傾向をあらわすと言える. 二つの派閥はよくもめる. そんなとき感情的になるのを避けるため, フレームワーク形式とライブラリ形式のどちらをとるかの判断基準ついて意識することには意味がある. </p><p></p><p>ライブラリ形式が必要な時</p><p>ライブラリ形式 (= 利用者が機能を呼びだす形式) が必要なのは, 利用者の望むタイミング(大抵はライブラリを呼びだした瞬間)に結果が欲しいケースだ. たとえば "レポジトリの値を読む" 操作, あるいは各種数値計算. ここでいう結果には副作用も含まれる: 例えば画面への描画, ウィンドウを開く/閉じる, データベースの値を書換えるなどは副作用にあたる.</p><p></p><p>フレームワーク形式が必要な時</p><p>フレームワーク形式 (= 利用者の登録した処理が呼びだされる形式) が必要なのは, 利用者がタイミングを決定できない時だ. 例えば CGI や servlet は Web ブラウザからアクセスされた時に処理を実行する. そのタイミングは当然 CGI 作成者には判断できない. だから (自分で HTTP Server を作らない限り) Web application は多少なりともフレームワークっぽくなる. main() を OS や JVM というフレームワークで定義された interface だと考えれば, これもタイミングを知ることのできない処理にあたる.</p><p></p><p>非同期と同期</p><p> こうしてタイミングに着目すると, ライブラリ形式は同期処理, フレームワーク形式は非同期処理に向いていることがわかる. だから同じ機能を提供するのにも同期性の問題から異なる形式をとることがある. たとえばネットワーク上のストリーム (HTTP など) は読み込みに時間がかかり, 処理がブロックするかもしれない.</p><p></p><p> 処理がブロック(同期)していいならライブラリ形式をとれる.</p><p></p><pre><p> ...</p><p> while (true) {</p><p>   byte[] buf = httpReader.read();</p><p>   if (null == buf) {</p><p>     break;</p><p>   } else {</p><p>     /* parsing stream ... */</p><p>   }</p><p> }</p><p> ...</p></pre><p></p><p> 非同期での読み出しが必要ならフレームワーク形式になる.</p><p></p><pre><p> class MyHTTPStreamHandler implements HTTPStreamHandler {</p><p>   ...</p><p>   void read( byte[] buf ) { // the signature is defined in HTTPStreamHandler</p><p>     /* parsing stream ... */</p><p>   }</p><p> }</p><p> </p><p> ...</p><p> </p><p> void foo() {</p><p>   ...</p><p>   HttpStreamReader reader = new HTTPStreamReader();</p><p>   reader.read( "http://www.example.com", 80, new MyHTTPStreamHandler( ... ) );</p><p>   ...</p><p> }</p><p> </p></pre><p></p><p> このように, タイミング/同期性は形式を要請する. だからその要請がはっきりしている時はあまりもめずに設計が決まることが多い.  メソッド呼出しがブロックしないと仮定すればライブラリ形式を貫きとおすことはできるし, 同期処理にフレームワーク形式を使うこともできる. しかしそのどちらどちらも利用者にとって煩雑. 一般的ではない.</p><p></p><p>どちらでもなんとかなる時</p><p>ライブラリ形式とフレームワーキ形式のどちらが望ましいかが上のようにすっぱり決まらないケースもある. XML パーサの <a href="http://www.saxproject.org/">SAX</a> と <a href="http://www.xmlpull.org/">XML Pull</a> がその良い例だ. 同じ機能(XMLJのパース)を実現するのに, フレームワーク形式(SAX)とライブラリ形式(Pull)の両方があり, どちらにも支持者がいる. ここで問題になっているのは複雑だ; SAX と Pull のどちらを使うのがより簡単なのだろうか.</p><p></p><p> まず, フレームワーク形式とライブラリ形式を交換する方法について確認. 単純化していうと, ライブラリによって取得できたデータをコールバックの引数に渡せばフレームワークになる. 逆にフレームワークのコールバックに渡る引数をオブジェクトに詰めてモジュール呼出しからの戻り値とすればライブラリになる. (その値はコンテクストに保存されてもいい. Pull は parser がコンテクストとして値を保持し, メソッドでそれをとりだす.) SAX/Pull の場合を例にとろう.</p><p></p><p> SAX では, 要素の開始を次のメソッドに通知する. Attributes は属性の配列だと思えばいい.</p><p></p><pre><p> public void startElement(java.lang.String uri,</p><p>                          java.lang.String localName,</p><p>                          java.lang.String qName,</p><p>                          Attributes atts) throws SAXException;</p><p>                  </p></pre><p></p><p> Pull では パーサの next() メソッドで次の token を読み出し, その種別に応じて 必要な情報をパーサから読み出す. parser は コンテクストとして, getName() など現在のトークン情報を取得するためのメソッドを持つ.</p><p></p><pre><p>  int eventType = parser.getEventType();</p><p>  while (eventType != parser.END_DOCUMENT) {</p><p>    if(eventType == parser.START_DOCUMENT) {</p><p>      ...</p><p>    } else if(eventType == parser.END_DOCUMENT) {</p><p>      ...</p><p>    } else if(eventType == parser.START_TAG) {</p><p>      ... /* we handle elements here in many cases. */</p><p>    } else if(eventType == parser.END_TAG) {</p><p>      ...</p><p>    } else if(eventType == parser.TEXT) {</p><p>      ...</p><p>    }</p><p>    eventType = parser.next();</p><p>  }</p></pre><p></p><p> "引数 - 戻り値" の変換ルールを使うことで書き換えることのできるものは多い. どちらが単純か, 拡張性があるか, 柔軟か. その判断は様々な要因に左右される. 設計者のセンスが問われる, と言って済ますこともできる. ただ, 判断に影響を与える要素をいくらかでも知っていればセンスに頼らない議論も少しはできるかもしれない.</p><p></p><p> 気が向いたらつづく.</p>
