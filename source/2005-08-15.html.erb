---
title: "少しのあいだせっせと働きつつぼちぼち勉強することにした"
date: 2005-08-15
---
<p>近況</p><p>少しのあいだせっせと働きつつぼちぼち勉強することにした. その手段として, 今日から一ヶ月は平日にウェブを見ないのを目標にする. ウェブで宣言することでなんとなく自分にプレッシャーをかけてみる. </p><p></p><p>ストリーム・プロセッサ</p><p>ひやかしで <a href="http://developer.nvidia.com/object/siggraph_2005_presentations.html">NVIDIA のスライド</a>を見ていたら, ストリーム・プロセッサというのが出てきた. 以前も似たような話をしていた気がするが, 結局それが何なのかはよくわからなかったのを思いだし Google に伺ってみる. Stanford 大学の <a href="http://cva.stanford.edu/imagine/">Imagine</a> が有名な様子. そこで適当に文書を拾って読む. (なので以下はストリーム・プロセサというより Imagine の話.) まず "<a href="ftp://cva.stanford.edu/pub/publications/spqueue.pdf">Stream Processors: Programmability with Efficiency</a>" で概要を. 要はキャッシュの読み出し/書き込みを制御できる(制御しなければならない)並列計算機なのだな. ストリーム・プロセサの応用は色々あると書いてはあるが, やはり主流はグラフィクスらしい.</p><p>そこで "<a href="http://graphics.stanford.edu/papers/jowens_thesis/">Computer Graphics on a Stream Architecture</a>" をちょっと読んでみた. Imagine を使って OpenGL を実装する, というような話. GPU がどう実装されているか想像する素材としては面白い. まず Imagine のつくりから. Imagine には代表的なコンポーネントが 4 つある. データを置くキャッシュである Stream Register File (SRF), SRF から実際の数値演算を行う複数の ALU Cluster (こいつのおかげで並列になる), ALU Culster を統制する Microcontroller, 主記憶との IO を担当する Stream Controller. SRF はけっこうでかくて 128kb. cluster は 8 個, Microcontroller の保持できる命令数は 2048. たとえば巨大な配列を順次処理する計算を考えるとこんな風になる: 1. 命令を Microcontroller に feed, 2. 部分配列を SRF にロード, 3. 各 ALU Culster が SRF を並列で参照しながら計算. 4. 計算結果 (これも SRF に書かれている) をメモリにストア. 簡単な計算だとこれで話はおしまいなのだが, 実際の計算はもっと複雑. SRF へのロード/ストアや, ALU へのデータ割り振りをどうスケジューリングするかが肝になる. 問題の複雑さゆえにハードウェアがインテリジェントにあれこれやるのは難しそうなので. コンパイラやプログラマが頑張らねばならない.</p><p>この Imagine の上でどう OpenGL のパイプラインを動かすのだろうか. シェーダを動かすのは比較的簡単だ. (もともと並列計算用に設計された言語だから.) ラスタライズは難しい. ラスタライズのカーネル(並列に動く関数)は三角形をうけとりフラグメントを出力する. フラグメントの量は可変で, 実行前に予測できない. これがくせもので, まず, 各 ALU Cluster の計算時間に差がでる. 隙間ができないようにうまくスケジューリングする必要がある. (これは Imagine がやってくれるらしい.) また, 動的に出力されるフラグメントをうまいことを保存し, フラグメントシェーダに渡してやる必要がある. ここの難しさは, たとえるなら ローカル変数を使うだけで済んですむプログラムと malloc() の必要なプログラムの違いのようなものだろうか. しかも仮想記憶(に相当する仕組み)はなさそうなので, でかいデータを自分で I/O する必要がある.</p><p>いくつかアイデアが示されているが, (SRF が一杯になったらでラスタライズを中断してたまったフラグメントを処理する, SRF から溢れた分はメモリに書き戻すなど) いずれにせよ遅いらしい. <q>The Rasterization state of the polygon rendering pipeline consumes the largest propotion of runtime in our implementation. Spatial-purpose rasterizatio hardware is at the core of today's commercial graphics processors...</q> とも書いてあり, 今のところは Stream Processor のアーキテクチャ上でスマートにラスタライズを実現することはできていないようだ. がっくり...</p><p>しかし, GPU を "マニュアルのキャッシュ I/O 付き並列計算機" と理解することで, 少しだけ GPU の上でおきていることを想像しやすくなった気はする.  ハードウェア・浮動小数版 sed なのか ? 違うよな, などと思っているよりは精神衛生上よろしいということにして寝ます. 気がむいたら続く.</p>
