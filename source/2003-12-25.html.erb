---
title: "たまには C++ の話を"
date: 2003-12-25
---
<!--<p>近況</p><p>さようなら と 言われるのと さようならと言え と言われるのではどちらが辛いか. ぼんやりそんなことをおもう. 失った信頼は戻らない.</p><p>  --></p><p></p><p>たまには C++ の話を.</p><p>気晴らしに.</p><p>C++ のライブラリについては, boost がおおよその物事を解決しそうな気配が見える. GUI や OS のサービスなど解決しない問題も本当は多い. けれど, C++ はもうそれについて解決する気がなさそう. この言語の良いところはそれが役に立たないところで, この言語の悪いところはそれが役にたつところだ. というのはレトリックだけれど, そういうところで中途半端に役に立とうとしない boost の姿勢からは C++ 利用者の総意を感じる. </p><p>C++ 言語仕様は相変らずどうしようもない. 諸悪の根源(のひとつ)が C 由来のポインタであることを Microsoft はよくわかっていて. 彼らはそれを改善しようとしている.</p><p></p><p>ハンドルとハット</p><p>次バージョン(次々バージョン？) の VisualStudio で, Microsoft は C++ を大きく拡張する. 現在ぎこちなく繋っている native C++ の世界と managed C++ の世界(.NET/CLI の世界) をシームレスに繋ぐための拡張. それをハンドルという. </p><p></p><p> 現在の VC++ では __xx というようなベンダ依存の修飾をつけることで, あるポインタを "これは .NET 世界のポインタですよ" と宣言する. これはわかりにくいし, あいかわらずポインタだ. ハンドルは違う. ハンドルはポインタと似ているがポインタ(=生の番地情報)ではなく, Java の参照のみたいなものだ. だから *p というように dereference することはもちろんできないし, p++ みたいなポインタ演算もできない. 非常に限定されている. かわりにガベージ・コレクションの対象になる.</p><p>Microsoft の大きな決断は, ハンドルを表わすのにアンダースコアによるベンダ拡張ではなく, 独自の文法, 演算子を定義したことだ. ハンドルは次のように宣言する.</p><p></p><pre><p> Button ^ b;</p><p> b = gcnew Button;</p></pre><p></p><p> "^" がハンドルをあらわす演算子. gcnew は managed なオブジェクトを生成するためのキーワードになる. "^" は見事な選択だと思う. これをオーバーロードする人はそういないだろう (...と思ったら <a href="http://boost.org/libs/spirit/doc/operators.html">spirit はオーバーロードしていた</a>.) とにかく, Microsoft は C++ の文法を拡張することで managed の世界と native の世界をうまく繋いだ. 重要なのはこの文法のもつ自然さにある. 機能的には アンダースコア装飾とそう差はないけれど, 心理的な障壁はおおきく違う. "^" は Microsoft 依存に躊躇する開発者の背中を押してくれる. ぽん.</p><p>当初は CLI のオブジェクトだけが gcnew で確保できる. 将来的には, native のオブジェクトを gcnew で確保すること(あるいはその逆)ができるようになるらしい. STL と .NET を混在させるようになるんだろうか. おそろしい. スタックの上はどうなるんだろう. ただでさえ例外処理やカナリアで騒々しいのに...</p><p>なお, こういった話題は Microsoft 運営のコミュニティサイト <a href="http://blogs.gotdotnet.com/">GOTDOTNET</a> にある <a href="http://blogs.gotdotnet.com/branbray/">Brandon Bray の weblog</a> や, その BLOGROLL (というのはリンク集のことらしい) から辿ることができる. C++ マニアには面白い話題だが分量も多い. 正月の暇潰しに読むにはよいかもしれない.</p><p></p><p>コンセプト</p><p>Microsoft の拡張が彼らの都合に合わせた独自路線なのに対し, guru of C++ である <a href="http://www.research.att.com/~bs/homepage.html">BS</a> が提案する C++ 拡張は我ら不毛の民の心を代弁している. boost の <a href="http://boost.org/libs/concept_check/concept_check.htm">concept_check</a> ライブラリを思いだそう. これは テンプレート引数の要件 = コンセプト を手続的に記述するライブラリだ. このアイデアを言語仕様としてとりこもうと BS は提案する. 目的は template の繰り出すエラーメッセージの爆発からプログラマを救うこと. <a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/">ISO C++ WG のページ</a> にある "<a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1522.pdf">Concepts - Design choices for template argument checking</a>" に概要がまとまっている. (関連資料も同じページにある. このページの文書群もまた C++ マニアの正月用テキストになりそう.)  アイデアはまとまりきっていないようだが, おおよそ次のように書けるらしい.</p><p></p><pre><p> concept Comparable {</p><p>   constraints( Comparable a, Comparable b ) {</p><p>     a == b; a != b; a == 1; a != 1; before(a,b); after(a,b);</p><p>   }</p><p> };</p><p> </p><p> template &lt;Comparable C&gt; class T {</p><p>    .....;</p><p> };</p></pre><p></p><p> 割と妥当なかんじ. しかし C++ にはこういう直観が通用しないから, 色々叩かれ修正されていくだろう. これが標準化, 実装されるのは今世紀の終わりくらいかな...という気がしてしまう. でも夢はあるね. BJ は "実装は難しいけど, concept をある種の class として扱えばまあなんとかなる" みたいなことをいっている. ほんとかよ...</p><p></p><p> C++ が複雑さの袋小路にはまりこんでいく様は, 外から眺める分には面白い. 彼らはどこに向かうのだろう. それを見届けたい気はする.</p>
