---
title: "To BLOB or Not To BLOB"
date: 2006-10-31
---
<pre></pre>
<h3>To BLOB or Not To BLOB</h3>
<p>なんとなく <a href="http://research.microsoft.com/~Gray/">Jim Gray のページ</a> を見ていたら, 
"<a href="http://research.microsoft.com/research/pubs/view.aspx?msr_tr_id=MSR-TR-2006-45">To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem?</a>" という記事があった. </p>
<p>データベース業界には "ちまいデータは BLOB に入れろ, でかいデータはファイルに置け" 
という口伝があるらしい. (業界ビトでない私はしらなかった...) 
でも "でかい" って具体的にどのくらいなんだろう. 
実験/ベンチマークをして BLOB とファイルシステムを比較, 
疑問に答えましたよというのがこの記事. 
このごろはビデオや写真をウェブに置くのもふつうになりつつある. 
そういうメディアなデータを保存する世相を知っておくのはいいかもしれない. 
読んでみた. </p>
<p>この実験では BLOB の実装に MS SQLServer, ファイルシステムに NTFS を使っている. 
(Jim Gray は MS Research の人ですからね.) 
実験の結果, サイズ 256KB 以下のデータには BLOB, 
1MB 以上ならファイルの性能が優勢だったという. 中間はグレーゾーン. ふーん. </p>
<p>256KB はけっこう大きい. 
たとえば少し前からウェブのスクリーンショットを提供するサービスが増えてきた. 
こういう画像の大きさはだいたい数KB から 数十KB. 
実験結果に従うなら, こういうのはデータベースに入れた方がいいことになる. 
運用の手間もあるから一概には言えないのだろうけれど, 
実際 BLOB ってどのくらい使われているんだろうね. </p>
<p>さて. この数字とは別に, 実験から得られた発見も色々載っていた. 
面白かったのでちょっと紹介. </p>
<h4>断片化の影響</h4>
<p>この実験ではただデータを読み書きするだけでなく, 
データを何度も上書き(update)したという. 内部レイアウトの断片化を招くためだ. 
上書きをくりかえすとシステムは "老化" する. 
著者らは老化によって生じるデータの断片化でどれくらい性能が落ちるのかを計測している. </p>
<p>SQLServer と NTFS では結構差が出ていて面白い. 
SQLServer は老化によるスループットの低下が著しい. 
老化に応じてデータの断片化が進み, どんどん遅くなる. 
逆に NTFS のスループットは老化が進んでも下げ止まり, 断片化もある割合に収束していく. 
要するに頻繁な巨大データの上書きをするシステムでは
ファイルシステム(NTFS)の方がいいということになる. 
もしデータベースを使うならときどきデフラグしなさいね, というわけ. </p>
<p>もう一つ面白いのは, データサイズの分布と断片化の関係だ. 
直感的には, データサイズが散らばっている方がデータの断片化は進みそうに見える. 
アロケータのアルゴリズムを何かしら知っていれば想像がつくだろう. 
それをたしかめるため, 著者らは同じサイズのデータの読み書きと, 
サイズが一様に分散したデータの読み書きによっておこる老化/断片化の度合いを調べている. </p>
<p>結果: どちらも変わらない. </p>
<p>意外な結果に驚く. (Jim Gray も驚いている.) 固定サイズと一様分布, 
性能のグラフはぴたりと重なっている. この傾向は SQLServer でも NTFS でも同じ. 
世にあるアロケーションのアルゴリズムが十分に枯れたから...ではないことは, 
SQLServer の結果から明らかだ. (NTFS より断然スループットの劣化がひどい.) 
なんでこうなるんだろう. 不思議...</p>
<h4>ベンチマークをとろう</h4>
<p>これら実験結果はどれも非常に面白いけれど, 
256KB だの 1MB だのという数字自体にはあまり意味がない. 
システムの構成によって数字に差があるのは間違いないからだ. 
世の中の LAMP の精は SQLServer や NTFS を使わないし, 
SQLServer 開発者もここまで言われて黙ってはいないだろう. </p>
<p>そのかわり, 性能を気にするならベンチマークをしようという当たり前の事実を再認識させられる. 
この記事は具体的なベンチマーク指標のケーススタディとして有意義だと思う. 
単にベンチマークをした方がいいと思っても, 何を測ればいいかは自明でない. 
そういう意味で, 時系列での性能劣化を測定する話はとても面白かった. 
私は所詮スタンドアロンなアプリケーションの開発者. 
プロファイラを有効にして起動, 終了, 結果を眺めるという瞬間芸しかしたことがない. 
長時間動かすソフトウェアは, それに相応しいベンチマークがあるんだね. </p>
<h4>To BLOB or Not To BLOB 昔話</h4>
<p>その後しばらくぐぐったところ, 
"<a href="http://www.geocities.jp/kimura804/rdb/InterBase/ip_ib_strings_j.htm">BLOBにする、しない、それが問題だ</a>" という記事をみつけた. 10 年くらい前のもの. </p>
<p>この記事の場合, BLOB の比較相手はファイルシステム(より大きいデータ)ではなく
普通の VARCHAR フィールド(より小さいデータ)らしい. たしかにそこも気にはなる. 
記事では性能の話より機能的な比較に論を割いている. 
ファイルシステムと対比する時の BLOB は単なるバイト列だから, 
ソートや連結といった DBMS の機能を使うことはあまりない. 
だから性能だけに着目することができた. 
逆にテキストデータの場合は構造を利用して色々やりたいことは多いのだろう. 
(<a href="http://dodgson.org/omo/t/?date=20061002">全文検索</a> もその一つ.) 
性能以前にそうした要件でつくりが決まることは多そう. </p>
<p>Jim Gray に乗せられ NTFS サイコーだ! などと密かに盛り上っていた気分をなだめました. </p>
<h4>参考リンク</h4>
<ul>
<li><a href="http://research.microsoft.com/research/pubs/view.aspx?msr_tr_id=MSR-TR-2006-45">To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem?</a></li>
<li>Web でみつけた民間伝承<ul>
<li><a href="http://deepselect.blogspot.com/2006/05/to-blob-or-not-to-blob.html">Deep Select: To BLOB Or Not To BLOB</a></li>
<li><a href="http://www.willasrari.com/blog/to-blob-or-not-to-blob/00073.aspx">Will Asrari - To BLOB or not to BLOB</a></li>
</ul></li>
<li><a href="http://www.cvalde.net/misc/blob_true_history.htm">The true story of BLOBs.</a> BLOB 誕生秘話: もともと略称じゃないんだぜ, という話.</li>
</ul>
